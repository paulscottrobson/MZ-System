; @codeonly

; ***********************************************************************************************
;
;			Find word in dictionary. HL points to name, on exit, HL is the address, D the
;			type ID and E the page number with CC if found, CS set and HL=DE=0 if not found.
;
; ***********************************************************************************************

DICTFindWord:
		push 	bc 								; save registers - return in DEHL Carry
		push 	ix

		ld 		a,DictionaryPage 				; switch to dictionary page
		setMemoryPageA

		ld 		ix,$C000 						; dictionary start			
__DICTFindMainLoop:
		ld 		a,(ix+0)						; examine offset, exit if zero.
		or 		a
		jr 		z,__DICTFindFail

		push 	ix 								; save pointers on stack.
		push 	hl 

__DICTCheckName:
		ld 		a,(ix+5) 						; compare dictionary vs character.
		xor 	(hl) 							; get the matching character.
		and 	$7F 							; ignore bit 7, for now.		
		jr 		nz,__DICTFindNoMatch 			; no, not the same word.
		inc 	hl 								; HL point to next character
		inc 	ix
		bit 	7,(ix+4) 						; have we matched everything, e.g. last match bit 7 was high.
		jr 		z,__DICTCheckName

		ld 		a,(hl)							; if so, see if the next one is EOW
		cp 		' '+1
		jr 		nc,__DICTFindNoMatch 			; if not , bad match.

		pop 	hl 								; Found a match. restore HL and IX
		pop 	ix
		ld 		d,(ix+4) 						; D = type/length
		ld 		e,(ix+1)						; E = page
		ld 		l,(ix+2)						; HL = address
		ld 		h,(ix+3)		
		xor 	a 								; clear the carry flag.
		jr 		__DICTFindExit

__DICTFindNoMatch:								; this one doesn't match.
		pop 	hl 								; restore HL and IX
		pop 	ix
__DICTFindNext:
		ld 		e,(ix+0)						; DE = offset
		ld 		d,$00
		add 	ix,de 							; next word.
		jr 		__DICTFindMainLoop				; and try the next one.

__DICTFindFail:
		ld 		de,$0000 						; return all zeros.
		ld 		hl,$0000
		scf 									; set carry flag
__DICTFindExit:
		pop 	ix 								; pop registers and return.
		pop 	bc
		ret

