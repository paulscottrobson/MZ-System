; @word	get.word.add.dictionary
		push	de
		push 	hl
		call 	PARSEGetNextWord 					; get the next word.
		jr 		c,__GWADError 						; nothing to get.
		call 	DICTAddWord 						; add it to the dictionary.
		resetMemoryPage 							; set the memory page back to A'
		pop 	hl
		pop 	de
		ret

__GWADError: 										; nothing to get.
		ld 		hl,__GWADMessage
		jp 		ErrorHandler
__GWADMessage:
		db 		"No word available for definition",0

; ***********************************************************************************************
;
;		Add Dictionary Word. Name is string at HL ends in <= ' ', uses the current page/pointer
;		values.
;
; ***********************************************************************************************

DICTAddWord:
		push 	af 									; registers to stack.
		push 	bc
		push 	de
		push	hl
		push 	ix
		push 	hl 									; put length of string in B
		ld 		b,-1
__DICTAddGetLength:
		ld 		a,(hl)
		inc 	hl
		inc 	b
		cp 		' '+1
		jr 		nc,__DICTAddGetLength
		pop 	hl

		ld 		a,DictionaryPage					; switch to dictionary page
		setMemoryPageA

		ld 		ix,$C000							; IX = Start of dictionary
__DICTFindEndDictionary:
		ld 		a,(ix+0) 							; follow down chain to the end
		or 		a
		jr 		z,__DICTCreateEntry
		ld 		e,a
		ld 		d,0
		add 	ix,de
		jr 		__DICTFindEndDictionary

__DICTCreateEntry:
		ld 		(DICTLastDefinedWord),ix 			; save last defined address.
		ld 		a,b
		add 	a,5
		ld 		(ix+0),a 							; offset is length + 5

		ld 		a,(SINextFreeCodePage)				; code page
		ld 		(ix+1),a
		ld 		de,(SINextFreeCode)					; code address
		ld 		(ix+2),e
		ld 		(ix+3),d 
		ld 		(ix+4),0 							; type information.

		ex 		de,hl 								; put name in DE
__DICTAddCopy:
		ld 		a,(de) 								; copy byte over as 7 bit ASCII.
		ld 		(ix+5),a
		inc 	de
		inc 	ix 									
		djnz	__DICTAddCopy 						; until string is copied over.
		set 	7,(ix+4) 							; set bit 7 of the last character

		ld 		(ix+5),0 							; write end of dictionary zero.

		pop 	ix 									; restore and exit
		pop 	hl
		pop 	de
		pop 	bc
		pop 	af
		ret

