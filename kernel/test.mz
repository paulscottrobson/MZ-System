// ***************************************************************************************
// ***************************************************************************************
//
//		Name : 		core.mz
//		Author :	paul@robsons.org.uk
//		Date : 		12th November 2018
//		Purpose :	Core MZ functionality.
//
// ***************************************************************************************
// ***************************************************************************************


// ***************************************************************************************
//
//						:: Define a word which just executes
//
// ***************************************************************************************


parse.get.define.word.immediate :: 							// Create a definition ::
	parse.get.define.word 									// which does that itself, e.g. creates a definition
;

// ***************************************************************************************
//	
//			: Defines a normal word - with a "call to compile to call here" prefix
//
// ***************************************************************************************

:: : 														// Create a definition :
	parse.get.define.word 									// It creates a definition
	205 c, 													// Compile CALL xxxx
	dictionary.find.immediate compile.default.header 		// Compile the address of the default header
	,
;

// ***************************************************************************************
//
//								variable defines a variable.
//
// ***************************************************************************************

:: __variable.handler 			 							// What the variable handler does when
	235 c, 33 c, r>a ,  									// a variable is called. Compile ex de,hl ; ld hl,addr
;

:: variable 
	parse.get.define.word 									// It creates a definition
	205 c, 													// Compile CALL xxxx
	dictionary.find.immediate __variable.handler 			// Compile the address of the handler, execed when word run
	,
	0 , 													// Compile space for the data itself.
;

// ***************************************************************************************
//
//		Premodifiers for variables !! x @@ x && x generate load/store/address code.
//
// ***************************************************************************************

:: && 
	235 c, 33 c, 											// compile ex de,hl ld hl,xxxx
	dictionary.find.check 									// Gets next thing in i/p stream, puts into A
	3 + 													// skip call to the actual address.
	, 														// Compile it.
;

:: !! 34 c, dictionary.find.check 3 + , ;					// The same, does ld (xxxx),hl
:: @@ 235 c, 42 c, dictionary.find.check 3 + , ; 			// The same, does ex de,hl ; ld hl,(xxxx)

// ***************************************************************************************
//
//								 Get code position
//
// ***************************************************************************************

: h sys.info ;
: here h @ ;

// ***************************************************************************************
//
//									For .. Next loop
//
// ***************************************************************************************

variable __for.loop.position 								// loop return

:: for 														// 5 for .. next index 4 3 2 1 0
	here !! __for.loop.position								// save loop return
	43 c, 229 c,  											// DEC HL ; PUSH HL	
; 															// A = index at loop start.


:: next 
	225 c, 124 c, 181 c, 									// POP HL ; LD A,H ; OR L
	194 c, @@ __for.loop.position , 						// JP NZ, <loop return>
;

:: i 	
	235 c, 225 c, 229 c, 									// EX DE,HL ; POP HL ; PUSH HL
;

// ***************************************************************************************
//
//							Begin .. Again/Until/-Until
//
// ***************************************************************************************

variable __begin.loop.position 								// loop return

:: begin
	here !! __begin.loop.position 							// Remember top of loop
;

:: again  													// Loop forever
	195 c, @@ __begin.loop.position , 						// JP <loop return>
;

:: -until 													// Loop until A -ve
	203 c, 124 c, 											// BIT 7,H
	202 c, @@ __begin.loop.position , 						// JP Z,<loop return>
;

:: until 													// Loop until A non zero
	124 c, 181 c, 											// LD A,H ; OR L
	202 c, @@ __begin.loop.position , 						// JP Z,<loop return>
;

// ***************************************************************************************
//
//									If/-If ... Then
//
// ***************************************************************************************

variable __if.branch.address 								// JP xxx - points to xxx

:: if
	124 c, 181 c, 											// LD A,H ; OR L
	202 c, 													// JP Z,<skip code>
	here !! __if.branch.address 							// save the address of the jump address
	0 , 													// Undefined loop return
;

:: -if
	203 c, 124 c, 											// BIT 7,H
	202 c, 													// JP Z,<skip code>
	here !! __if.branch.address 							// save the address of the jump address
	0 , 													// Undefined loop return
;

:: then 	
	here a>r @@ __if.branch.address h !  					// Shift here back to the address
	r>a , h !  												// Compile here into jump, and set it back.
;

:: hello 
	break 15 for
		7 - -if .hex then
	next

debug  halt ;

hello
